import assignIn from 'lodash.assignin';
import fs from 'graceful-fs';
import temp from 'temp';

import { logger } from '../logger';
import { runScript } from '../edge-loader';
import { nativeInterop } from '../native-interop';
import { requireTaskPool } from 'electron-remote';
import { IS_WINDOWS_STORE } from '../utils/shared-constants';

const { downloadFileOrUrl } = requireTaskPool(require.resolve('electron-remote/remote-ajax'));
const isWindows10OrHigher = nativeInterop.isWindows10OrHigher();

temp.track();

let notifier;
let tileNotifier;

export default class WindowsNativeNotification {
  /**
   * Creates a notification and dispatches it (per HTML5 Notification).
   *
   * @param  {String} title   The notification title
   * @param  {Object} options Additional arguments to create the notification
   */
  constructor(title, options={}) {
    assignIn(this, options);
    assignIn(this, require('../renderer/event-listener'));

    let toSend = {
      ...options,
      title
    };

    logger.debug('Constructing new WindowsNativeNotification', {...options, body: '[redacted]'});

    this.downloadImages(toSend, ['imageUri', 'avatarImage'])
      .then((opts) => this.createNotification(opts))
      .catch((e) => this.dispatchError(e));
  }

  /**
   * Download the images specified by the keys and set them as file URLs on the
   * options object.
   *
   * @param  {Object} options Arguments to create the notification
   * @param  {Array} keys     An array of keys that describe the image URls
   * @return {Object}         The modified options object
   */
  async downloadImages(options, keys) {
    for (let key of keys) {
      if (options[key]) {
        logger.debug('NativeNotification: Downloading image', options[key]);

        let target = await this.downloadImage(options[key]);
        if (target) {
          options[`${key}Web`] = options[key];
          options[key] = `file:///${target.replace(/\\/g, '/')}`;
        }
      }
    }
    return options;
  }

  /**
   * Creates a notification using the native modules generated by NodeRT, if
   * Windows 10, otherwise use Edge.js to shell out to our notifier DLL.
   *
   * @param  {Object} options Arguments to create the notification
   */
  async createNotification(options) {
    let result;

    if (isWindows10OrHigher) {
      notifier = notifier || require('../renderer/components/node-rt-toast-notification').default;

      if (IS_WINDOWS_STORE) {
        try {
          logger.debug('NativeNotification: Creating new NodeRT tile notification.');
          tileNotifier = tileNotifier || require('../renderer/components/node-rt-tile-notification').default;
          tileNotifier(options);
        } catch (e) {
          logger.warn('NativeNotification: Sending tile notification failed with error.', e);
        }
      }

      logger.info('NativeNotification: Creating new NodeRT toast notification.');
      result = await notifier(options);
    } else {
      logger.info('NativeNotification: Creating new CSX toast notification.');
      notifier = notifier || await runScript({
        absolutePath: require.resolve('./native-notifications.csx')
      });
      result = await notifier(JSON.stringify(options));
    }

    this.dispatchEvent(result ? 'click' : 'close', { target: this });
    return result;
  }

  /**
   * Closes the notification early. Not implemented.
   */
  close() {
  }

  /**
   * Marshals an error to the 'error' event.
   *
   * @param  {Exception} error The exception thrown
   */
  dispatchError(error) {
    // WinRT only returns an errorCode, so that's what we get from NodeRT
    if (isWindows10OrHigher) {
      logger.warn('NativeNotification: Error while showing notification: WinRT error.', error);
    } else {
      logger.warn('NativeNotification: Error while showing notification:', error);
    }

    this.dispatchEventWithReplay('error', {
      target: this,
      type: 'error',
      error: error
    });

    this.clearListeners();
  }

  async downloadImage(uri) {
    let target = null;

    // Open up temporary file
    try {
      let { path } = temp.openSync('notif');
      target = path;
      logger.debug('Created new temporary image path:', path);
    } catch (e) {
      logger.error('Failed to set up notification image:', e);
      return null;
    }

    setTimeout(() => {
      try {
        logger.debug('Attempting to remove temporary image path:', target);
        fs.unlinkSync(target);
      } catch(e) {
        logger.info(`Couldn't clean up temp notification image:`, e);
      }
    }, 15 * 1000);

    if (await downloadFileOrUrl(uri, target) < 10) {
      return null;
    }

    return target;
  }
}
