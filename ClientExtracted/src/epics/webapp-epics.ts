import { MiddlewareAPI } from 'redux';
import { ActionsObservable, Epic } from 'redux-observable';
import { idle } from 'rxjs-requestidlecallback-scheduler';
import { Observable } from 'rxjs/Observable';

import { Action } from '../actions/action';
import { APP_TEAMS, EVENTS, NOTIFICATIONS, SELECTED_TEAM_ACTION } from '../actions/index';
import { completeAction } from '../custom-operators';
import { logger } from '../logger';
import { RootState } from '../reducers/index';
import { assignApiToken, getTokenForTeam } from '../reducers/tokens-reducer';
import { TELEMETRY_EVENT, track } from '../telemetry';
import { WEBVIEW_LIFECYCLE } from '../utils/shared-constants';
import { executeJavaScriptOnWebView, executeJavaScriptOnWebViewObservable } from './execute-javascript-on-webview';
import { pickActionData } from './pick-action-data';
import {
  NotificationClickArgs,
  NotificationReplyArgs,
  serializeNotificationClickCode,
  serializeNotificationReplyCode,
  serializeTickleCode
} from './serialize-code';
import { WebViewLifeCycleBase, WebViewLifeCycleEpic } from './web-view-life-cycle';

import '../custom-operators';
import '../rx-operators';

/**
 * WebViewContext epics control our <WebViewContext/> and actions generated by
 * the webview process, like focus events. Webapp epics control the embedded
 * page within the webview process (aka, the webapp), and are mostly used to
 * execute code in the webapp context.
 */

/**
 * For actions broadcast from a single webview to all listeners, the webview
 * sometimes needs an identifier - Assign team id as global identifier.
 */
const assignTeamIdEpic: Epic<Action<any>, RootState> =
  (actionObservable: ActionsObservable<Action<any>>, _store: MiddlewareAPI<RootState>) =>
    actionObservable.ofType(WEBVIEW_LIFECYCLE.PAGE_LOADED)
      .map((x) => ({ id: (x as any).id, code: `window.teamId = \"${(x as any).id}\"` }))
      .do((x) => logger.debug('assignTeamIdEpic', x.code))
      .let(executeJavaScriptOnWebView)
      .let(completeAction);

/**
 * When a team finishes loading the webapp, retrieve its API token & stash it
 * in the store.
 */
const retrieveApiTokenEpic: Epic<Action<any>, RootState> =
  (actionObservable: ActionsObservable<Action<any>>, store: MiddlewareAPI<RootState>) =>
    actionObservable.ofType(WEBVIEW_LIFECYCLE.WEBAPP_LOADED)
      .filter(({ id }: any) => !getTokenForTeam(store, id))
      .map(({ id }: any) => ({ id, code: 'TS.model.api_token' }))
      .flatMap((args) =>
        Observable.of(args)
          .let(executeJavaScriptOnWebView)
          .filter((token) => !!token)
          .map((token) => ({ teamId: args.id, token })))
      .map(assignApiToken);

/**
 * Ping message server based on team's webapp loaded status.
 * If webapp is not loaded (either minweb or full), will not request ping.
 */
const tickleMessageServerEpic: WebViewLifeCycleEpic<Action<any>, RootState, WebViewLifeCycleBase> =
  (actionObservable: ActionsObservable<Action<any>>, _store: MiddlewareAPI<RootState>, state: WebViewLifeCycleBase) =>
    actionObservable.ofType(EVENTS.TICKLE_MESSAGE_SERVER)
      .map((x) => serializeTickleCode(x.data, state))
      .filter((x) => !!x.code)
      .let(executeJavaScriptOnWebView)
      .let(completeAction);

/**
 * Report telemetry to clogs when desktop client team switches.
 */
const teamSwitchTelemetryEpic: Epic<Action<any>, RootState> =
  (actionObservable: ActionsObservable<Action<any>>, store: MiddlewareAPI<RootState>) =>
    actionObservable.ofType(...SELECTED_TEAM_ACTION)
      .filter((x) => !!x.data && !!x.data.updated)
      .timeInterval()
      .subscribeOn(idle)
      .do((x) => track(TELEMETRY_EVENT.DESKTOP_TEAM_SWITCH, {
        teamSwitchReason: x.value.type,
        teamSwitchInterval: x.interval,
        selectedTeam: store.getState().appTeams.selectedTeamId
      }))
      .let(completeAction);

/**
 * Switch selected team / channel corresponding to notification message clicked.
 */
const clickNotificationEpic: WebViewLifeCycleEpic<Action<any>, RootState, WebViewLifeCycleBase> =
  (actionObservable: ActionsObservable<Action<any>>, _store: MiddlewareAPI<RootState>, state: WebViewLifeCycleBase) =>
    actionObservable.ofType(NOTIFICATIONS.CLICK_NOTIFICATION)
      .filter((x) => !!x.data && !!x.data.updated)
      .map((action) => pickActionData<NotificationClickArgs>(action.data))
      .map((notificationArgs) => serializeNotificationClickCode(notificationArgs, state))
      .flatMap((args) => executeJavaScriptOnWebViewObservable(args).mapTo(args.id))
      .map((teamId) => ({ type: APP_TEAMS.SELECT_TEAM, data: teamId }));

/**
 * Send reply from notification reply message.
 */
const replyNotificationEpic: WebViewLifeCycleEpic<Action<any>, RootState, WebViewLifeCycleBase> =
  (actionObservable: ActionsObservable<Action<any>>, _store: MiddlewareAPI<RootState>, state: WebViewLifeCycleBase) =>
    actionObservable.ofType(NOTIFICATIONS.REPLY_TO_NOTIFICATION)
      .filter((x) => !!x.data && !!x.data.updated)
      .map((action) => pickActionData<NotificationReplyArgs>(action.data))
      .map((replyArgs) => serializeNotificationReplyCode(replyArgs, state))
      .let(executeJavaScriptOnWebView)
      .let(completeAction);

const webAppEpics: Array<Epic<any, any>> = [
  assignTeamIdEpic,
  retrieveApiTokenEpic,
  tickleMessageServerEpic as any,
  teamSwitchTelemetryEpic,
  clickNotificationEpic,
  replyNotificationEpic
];

export {
  pickActionData,
  assignTeamIdEpic,
  retrieveApiTokenEpic,
  tickleMessageServerEpic,
  teamSwitchTelemetryEpic,
  clickNotificationEpic,
  replyNotificationEpic,
  webAppEpics
};
